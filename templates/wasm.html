<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibre Library - WASM Browser</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- sql.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.min.js"></script>
    <style>
        /* Additional styles for WASM browser */
        .status-bar {
            background: #34495e;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-bar .status-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .status-bar .badge {
            background: #27ae60;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.75rem;
        }
        .status-bar .badge.loading {
            background: #f39c12;
        }
        .status-bar .badge.error {
            background: #e74c3c;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #ecf0f1;
            border-top-color: #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-text {
            margin-top: 1rem;
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        .progress-bar {
            width: 300px;
            height: 6px;
            background: #ecf0f1;
            border-radius: 3px;
            margin-top: 1rem;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background: #3498db;
            transition: width 0.3s;
        }
        .setup-inline {
            max-width: 500px;
            margin: 2rem auto;
            padding: 2rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .setup-inline h2 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }
        .setup-inline p {
            color: #7f8c8d;
            margin-bottom: 1.5rem;
        }
        .setup-form-inline .form-group {
            margin-bottom: 1.5rem;
        }
        .setup-form-inline label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }
        .setup-form-inline input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ecf0f1;
            border-radius: 4px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        .setup-form-inline input:focus {
            outline: none;
            border-color: #3498db;
        }
        .setup-form-inline small {
            display: block;
            margin-top: 0.5rem;
            color: #7f8c8d;
            font-size: 0.85rem;
        }
        .setup-button {
            width: 100%;
            padding: 1rem;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
        }
        .setup-button:hover {
            background-color: #2980b9;
        }
        .setup-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .error-message {
            background-color: #fee;
            color: #c00;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }
        .book-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .book-modal-content {
            background: white;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 8px;
            padding: 2rem;
            margin: 1rem;
            position: relative;
        }
        .book-modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #7f8c8d;
        }
        .book-modal-close:hover {
            color: #2c3e50;
        }
        .perf-stats {
            font-size: 0.75rem;
            color: #95a5a6;
        }
        .nav-link {
            color: #3498db;
            text-decoration: none;
            margin-left: 1rem;
        }
        .nav-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h1 style="margin: 0;">
                    <a href="/wasm" style="color: white; text-decoration: none;">Calibre Library</a>
                    <span style="font-size: 0.6em; color: #3498db; margin-left: 0.5rem;">WASM</span>
                </h1>
                <div>
                    <a href="/" class="nav-link" style="color: white;">Server Mode</a>
                    <button id="changeLibraryBtn" onclick="resetLibrary()" style="background: none; border: none; color: white; cursor: pointer; font-size: 0.9rem; margin-left: 1rem;">Change Library</button>
                </div>
            </div>
            <form id="searchForm" class="search-form" style="display: none;">
                <input type="text" id="searchInput" placeholder="Search books or authors... (instant!)">
                <button type="submit">Search</button>
            </form>
        </div>
    </header>

    <div id="statusBar" class="status-bar" style="display: none;">
        <div class="status-text">
            <span id="statusBadge" class="badge">Ready</span>
            <span id="statusMessage">Database loaded</span>
        </div>
        <div class="perf-stats">
            <span id="perfStats"></span>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <div id="loadingText" class="loading-text">Initializing...</div>
        <div class="progress-bar">
            <div id="progressBarFill" class="progress-bar-fill" style="width: 0%"></div>
        </div>
    </div>

    <main class="container">
        <!-- Setup Section -->
        <div id="setupSection">
            <div class="setup-inline">
                <h2>Configure Calibre Library (WASM Mode)</h2>
                <p>This version runs SQLite entirely in your browser using WebAssembly. Your database is downloaded once and all queries run locally - instant search!</p>

                <div id="setupError" class="error-message" style="display: none;"></div>

                <form id="setupForm" class="setup-form-inline">
                    <div class="form-group">
                        <label for="libraryPath">Calibre Library Path</label>
                        <input
                            type="text"
                            id="libraryPath"
                            name="libraryPath"
                            placeholder="/Calibre Library"
                            required
                        >
                        <small>The folder path in Dropbox containing your Calibre library</small>
                    </div>
                    <button type="submit" class="setup-button" id="setupButton">
                        Load Library
                    </button>
                </form>
            </div>
        </div>

        <!-- Library Section -->
        <div id="librarySection" style="display: none;">
            <div class="library-header">
                <h2 id="libraryTitle">All Books</h2>
                <p class="book-count"><span id="bookCount">0</span> books found <span id="queryTime" class="perf-stats"></span></p>
            </div>

            <div id="booksGrid" class="books-grid"></div>

            <div id="pagination" class="pagination" style="display: none;">
                <button id="prevBtn" class="pagination-link" onclick="prevPage()">Previous</button>
                <span id="pageInfo" class="pagination-info">Page 1 of 1</span>
                <button id="nextBtn" class="pagination-link" onclick="nextPage()">Next</button>
            </div>
        </div>
    </main>

    <!-- Book Detail Modal -->
    <div id="bookModal" class="book-modal" style="display: none;">
        <div class="book-modal-content">
            <button class="book-modal-close" onclick="closeModal()">&times;</button>
            <div id="bookDetail"></div>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>Powered by Calibre + sql.js (SQLite WASM)</p>
        </div>
    </footer>

    <script>
    // Global state
    let db = null;
    let SQL = null;
    let currentPage = 1;
    let perPage = 20;
    let currentSearch = '';
    let totalBooks = 0;

    const LIBRARY_PATH_KEY = 'calibreLibraryPath';
    const DB_CACHE_KEY = 'calibreMetadataDB';

    // DOM elements
    const setupSection = document.getElementById('setupSection');
    const librarySection = document.getElementById('librarySection');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const progressBarFill = document.getElementById('progressBarFill');
    const searchForm = document.getElementById('searchForm');
    const searchInput = document.getElementById('searchInput');
    const statusBar = document.getElementById('statusBar');
    const statusBadge = document.getElementById('statusBadge');
    const statusMessage = document.getElementById('statusMessage');
    const setupError = document.getElementById('setupError');
    const setupButton = document.getElementById('setupButton');
    const libraryPathInput = document.getElementById('libraryPath');

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', init);

    async function init() {
        const storedPath = localStorage.getItem(LIBRARY_PATH_KEY);

        if (storedPath) {
            libraryPathInput.value = storedPath;
            await loadDatabase(storedPath);
        } else {
            setupSection.style.display = 'block';
        }
    }

    // Setup form handler
    document.getElementById('setupForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const libraryPath = libraryPathInput.value.trim();

        if (!libraryPath) {
            showSetupError('Library path is required');
            return;
        }

        localStorage.setItem(LIBRARY_PATH_KEY, libraryPath);
        await loadDatabase(libraryPath);
    });

    // Search handler with debounce
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            currentSearch = e.target.value.trim();
            currentPage = 1;
            renderBooks();
        }, 150); // Fast debounce for instant feel
    });

    searchForm.addEventListener('submit', (e) => {
        e.preventDefault();
        currentSearch = searchInput.value.trim();
        currentPage = 1;
        renderBooks();
    });

    async function loadDatabase(libraryPath) {
        showLoading('Initializing sql.js...');
        setProgress(10);

        try {
            // Initialize sql.js
            if (!SQL) {
                SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                });
            }
            setProgress(30);

            // Try to load from IndexedDB cache first
            showLoading('Checking cache...');
            let dbData = await loadFromCache();

            if (dbData) {
                showLoading('Loading from cache...');
                setProgress(70);
            } else {
                // Download from server
                showLoading('Downloading database from Dropbox...');
                setProgress(40);

                const response = await fetch('/api/download-db', {
                    headers: {
                        'X-Library-Path': libraryPath
                    }
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to download database');
                }

                setProgress(60);
                showLoading('Processing database...');

                const arrayBuffer = await response.arrayBuffer();
                dbData = new Uint8Array(arrayBuffer);

                // Cache in IndexedDB
                setProgress(80);
                showLoading('Caching for offline use...');
                await saveToCache(dbData);
            }

            setProgress(90);
            showLoading('Opening database...');

            // Create database from data
            db = new SQL.Database(dbData);

            setProgress(100);
            hideLoading();

            // Show library
            setupSection.style.display = 'none';
            librarySection.style.display = 'block';
            searchForm.style.display = 'flex';
            statusBar.style.display = 'flex';

            updateStatus('Ready', `Database loaded (${formatBytes(dbData.length)})`, 'ready');

            // Render books
            renderBooks();

        } catch (error) {
            console.error('Failed to load database:', error);
            hideLoading();
            showSetupError(error.message);
            setupSection.style.display = 'block';
            librarySection.style.display = 'none';
        }
    }

    function renderBooks() {
        if (!db) return;

        const startTime = performance.now();

        let books, total;

        if (currentSearch) {
            const result = searchBooks(currentSearch, currentPage, perPage);
            books = result.books;
            total = result.total;
            document.getElementById('libraryTitle').textContent = `Search: "${currentSearch}"`;
        } else {
            const result = getBooks(currentPage, perPage);
            books = result.books;
            total = result.total;
            document.getElementById('libraryTitle').textContent = 'All Books';
        }

        const queryTime = performance.now() - startTime;
        totalBooks = total;

        document.getElementById('bookCount').textContent = total;
        document.getElementById('queryTime').textContent = `(${queryTime.toFixed(1)}ms)`;
        document.getElementById('perfStats').textContent = `Query: ${queryTime.toFixed(1)}ms`;

        // Render grid
        const grid = document.getElementById('booksGrid');
        grid.innerHTML = books.map(book => `
            <div class="book-card" onclick="showBookDetail(${book.id})">
                <div class="book-link">
                    <div class="book-cover placeholder-cover">
                        <span>&#128218;</span>
                    </div>
                    <div class="book-info">
                        <h3 class="book-title">${escapeHtml(book.title)}</h3>
                        ${book.authors ? `<p class="book-author">${escapeHtml(book.authors)}</p>` : ''}
                        ${book.series ? `<p class="book-series">${escapeHtml(book.series)}${book.series_index ? ` #${book.series_index}` : ''}</p>` : ''}
                        ${book.rating ? `<div class="book-rating">${renderStars(book.rating)}</div>` : ''}
                    </div>
                </div>
            </div>
        `).join('');

        // Update pagination
        const totalPages = Math.ceil(total / perPage);
        const pagination = document.getElementById('pagination');

        if (totalPages > 1) {
            pagination.style.display = 'flex';
            document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages}`;
            document.getElementById('prevBtn').disabled = currentPage <= 1;
            document.getElementById('nextBtn').disabled = currentPage >= totalPages;
        } else {
            pagination.style.display = 'none';
        }
    }

    function getBooks(page, limit) {
        const offset = (page - 1) * limit;

        // Get total count
        const countResult = db.exec("SELECT COUNT(*) as count FROM books");
        const total = countResult[0].values[0][0];

        // Get books with authors, series, ratings
        const query = `
            SELECT
                b.id,
                b.title,
                b.path,
                b.has_cover,
                b.series_index,
                GROUP_CONCAT(a.name, ' & ') as authors,
                s.name as series,
                r.rating
            FROM books b
            LEFT JOIN books_authors_link bal ON b.id = bal.book
            LEFT JOIN authors a ON bal.author = a.id
            LEFT JOIN books_series_link bsl ON b.id = bsl.book
            LEFT JOIN series s ON bsl.series = s.id
            LEFT JOIN books_ratings_link brl ON b.id = brl.book
            LEFT JOIN ratings r ON brl.rating = r.id
            GROUP BY b.id
            ORDER BY b.sort
            LIMIT ${limit} OFFSET ${offset}
        `;

        const result = db.exec(query);
        const books = resultToObjects(result);

        return { books, total };
    }

    function searchBooks(term, page, limit) {
        const offset = (page - 1) * limit;
        const searchPattern = `%${term}%`;

        // Get total count
        const countQuery = `
            SELECT COUNT(DISTINCT b.id) as count
            FROM books b
            LEFT JOIN books_authors_link bal ON b.id = bal.book
            LEFT JOIN authors a ON bal.author = a.id
            WHERE b.title LIKE ? OR a.name LIKE ?
        `;

        const countStmt = db.prepare(countQuery);
        countStmt.bind([searchPattern, searchPattern]);
        countStmt.step();
        const total = countStmt.get()[0];
        countStmt.free();

        // Get books
        const query = `
            SELECT DISTINCT
                b.id,
                b.title,
                b.path,
                b.has_cover,
                b.series_index,
                GROUP_CONCAT(a.name, ' & ') as authors,
                s.name as series,
                r.rating
            FROM books b
            LEFT JOIN books_authors_link bal ON b.id = bal.book
            LEFT JOIN authors a ON bal.author = a.id
            LEFT JOIN books_series_link bsl ON b.id = bsl.book
            LEFT JOIN series s ON bsl.series = s.id
            LEFT JOIN books_ratings_link brl ON b.id = brl.book
            LEFT JOIN ratings r ON brl.rating = r.id
            WHERE b.title LIKE ? OR a.name LIKE ?
            GROUP BY b.id
            ORDER BY b.sort
            LIMIT ? OFFSET ?
        `;

        const stmt = db.prepare(query);
        stmt.bind([searchPattern, searchPattern, limit, offset]);

        const books = [];
        while (stmt.step()) {
            const row = stmt.getAsObject();
            books.push(row);
        }
        stmt.free();

        return { books, total };
    }

    function showBookDetail(bookId) {
        if (!db) return;

        const startTime = performance.now();

        // Get basic book info
        const query = `
            SELECT
                b.id,
                b.title,
                b.path,
                b.has_cover,
                b.pubdate,
                b.series_index,
                b.uuid,
                s.name as series,
                r.rating,
                p.name as publisher,
                c.text as comments
            FROM books b
            LEFT JOIN books_series_link bsl ON b.id = bsl.book
            LEFT JOIN series s ON bsl.series = s.id
            LEFT JOIN books_ratings_link brl ON b.id = brl.book
            LEFT JOIN ratings r ON brl.rating = r.id
            LEFT JOIN books_publishers_link bpl ON b.id = bpl.book
            LEFT JOIN publishers p ON bpl.publisher = p.id
            LEFT JOIN comments c ON b.id = c.book
            WHERE b.id = ?
        `;

        const stmt = db.prepare(query);
        stmt.bind([bookId]);
        stmt.step();
        const book = stmt.getAsObject();
        stmt.free();

        if (!book.id) {
            alert('Book not found');
            return;
        }

        // Get authors
        const authorsResult = db.exec(`
            SELECT a.name FROM authors a
            JOIN books_authors_link bal ON a.id = bal.author
            WHERE bal.book = ${bookId}
        `);
        book.authors = authorsResult.length ? authorsResult[0].values.map(r => r[0]) : [];

        // Get tags
        const tagsResult = db.exec(`
            SELECT t.name FROM tags t
            JOIN books_tags_link btl ON t.id = btl.tag
            WHERE btl.book = ${bookId}
        `);
        book.tags = tagsResult.length ? tagsResult[0].values.map(r => r[0]) : [];

        // Get formats
        const formatsResult = db.exec(`
            SELECT format, uncompressed_size FROM data
            WHERE book = ${bookId}
        `);
        book.formats = formatsResult.length ? formatsResult[0].values.map(r => ({ format: r[0], size: r[1] })) : [];

        // Get identifiers
        const identifiersResult = db.exec(`
            SELECT type, val FROM identifiers
            WHERE book = ${bookId}
        `);
        book.identifiers = {};
        if (identifiersResult.length) {
            identifiersResult[0].values.forEach(r => {
                book.identifiers[r[0]] = r[1];
            });
        }

        const queryTime = performance.now() - startTime;

        // Render modal
        document.getElementById('bookDetail').innerHTML = `
            <div class="book-detail-container" style="display: block; box-shadow: none; padding: 0;">
                <h1 style="margin-bottom: 1rem;">${escapeHtml(book.title)}</h1>

                ${book.authors.length ? `<p class="detail-authors"><strong>Authors:</strong> ${book.authors.map(a => escapeHtml(a)).join(', ')}</p>` : ''}

                ${book.series ? `<p class="detail-series"><strong>Series:</strong> ${escapeHtml(book.series)}${book.series_index ? ` #${book.series_index}` : ''}</p>` : ''}

                ${book.rating ? `<p class="detail-rating">${renderStars(book.rating)}</p>` : ''}

                ${book.publisher ? `<p><strong>Publisher:</strong> ${escapeHtml(book.publisher)}</p>` : ''}

                ${book.pubdate ? `<p><strong>Published:</strong> ${new Date(book.pubdate).toLocaleDateString()}</p>` : ''}

                ${book.tags.length ? `
                    <div class="detail-tags" style="margin: 1rem 0;">
                        ${book.tags.map(t => `<span class="tag">${escapeHtml(t)}</span>`).join('')}
                    </div>
                ` : ''}

                ${book.formats.length ? `
                    <div class="detail-formats" style="margin: 1rem 0;">
                        <strong>Formats:</strong>
                        ${book.formats.map(f => `<span class="format-badge">${f.format}</span>`).join('')}
                    </div>
                ` : ''}

                ${book.comments ? `
                    <div class="detail-description">
                        <strong>Description:</strong>
                        <div class="description-text">${book.comments}</div>
                    </div>
                ` : ''}

                ${Object.keys(book.identifiers).length ? `
                    <div class="detail-identifiers" style="margin-top: 1rem;">
                        <strong>Identifiers:</strong>
                        ${Object.entries(book.identifiers).map(([k, v]) => `${k.toUpperCase()}: ${escapeHtml(v)}`).join(' | ')}
                    </div>
                ` : ''}

                <p class="perf-stats" style="margin-top: 1rem;">Query time: ${queryTime.toFixed(1)}ms</p>
            </div>
        `;

        document.getElementById('bookModal').style.display = 'flex';
    }

    function closeModal() {
        document.getElementById('bookModal').style.display = 'none';
    }

    // Close modal on escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeModal();
    });

    // Close modal on background click
    document.getElementById('bookModal').addEventListener('click', (e) => {
        if (e.target.id === 'bookModal') closeModal();
    });

    function prevPage() {
        if (currentPage > 1) {
            currentPage--;
            renderBooks();
            window.scrollTo(0, 0);
        }
    }

    function nextPage() {
        const totalPages = Math.ceil(totalBooks / perPage);
        if (currentPage < totalPages) {
            currentPage++;
            renderBooks();
            window.scrollTo(0, 0);
        }
    }

    function resetLibrary() {
        localStorage.removeItem(LIBRARY_PATH_KEY);
        clearCache();
        db = null;
        setupSection.style.display = 'block';
        librarySection.style.display = 'none';
        searchForm.style.display = 'none';
        statusBar.style.display = 'none';
    }

    // IndexedDB cache functions
    function openCacheDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('CalibreWASM', 1);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('cache')) {
                    db.createObjectStore('cache');
                }
            };
        });
    }

    async function saveToCache(data) {
        try {
            const cacheDB = await openCacheDB();
            const tx = cacheDB.transaction('cache', 'readwrite');
            const store = tx.objectStore('cache');
            store.put(data, DB_CACHE_KEY);
            store.put(Date.now(), DB_CACHE_KEY + '_timestamp');
            store.put(localStorage.getItem(LIBRARY_PATH_KEY), DB_CACHE_KEY + '_path');
            await new Promise((resolve, reject) => {
                tx.oncomplete = resolve;
                tx.onerror = () => reject(tx.error);
            });
        } catch (e) {
            console.warn('Failed to cache database:', e);
        }
    }

    async function loadFromCache() {
        try {
            const cacheDB = await openCacheDB();
            const tx = cacheDB.transaction('cache', 'readonly');
            const store = tx.objectStore('cache');

            const currentPath = localStorage.getItem(LIBRARY_PATH_KEY);
            const cachedPath = await new Promise((resolve, reject) => {
                const req = store.get(DB_CACHE_KEY + '_path');
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });

            // If path changed, don't use cache
            if (cachedPath !== currentPath) {
                return null;
            }

            const data = await new Promise((resolve, reject) => {
                const req = store.get(DB_CACHE_KEY);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });

            return data || null;
        } catch (e) {
            console.warn('Failed to load from cache:', e);
            return null;
        }
    }

    async function clearCache() {
        try {
            const cacheDB = await openCacheDB();
            const tx = cacheDB.transaction('cache', 'readwrite');
            const store = tx.objectStore('cache');
            store.delete(DB_CACHE_KEY);
            store.delete(DB_CACHE_KEY + '_timestamp');
            store.delete(DB_CACHE_KEY + '_path');
        } catch (e) {
            console.warn('Failed to clear cache:', e);
        }
    }

    // Utility functions
    function resultToObjects(result) {
        if (!result.length) return [];
        const columns = result[0].columns;
        return result[0].values.map(row => {
            const obj = {};
            columns.forEach((col, i) => {
                obj[col] = row[i];
            });
            return obj;
        });
    }

    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function renderStars(rating) {
        const stars = Math.floor((rating || 0) / 2);
        return '&#9733;'.repeat(stars) + '&#9734;'.repeat(5 - stars);
    }

    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function showLoading(text) {
        loadingOverlay.style.display = 'flex';
        loadingText.textContent = text;
    }

    function hideLoading() {
        loadingOverlay.style.display = 'none';
    }

    function setProgress(percent) {
        progressBarFill.style.width = percent + '%';
    }

    function updateStatus(badge, message, type = 'ready') {
        statusBadge.textContent = badge;
        statusBadge.className = 'badge' + (type !== 'ready' ? ' ' + type : '');
        statusMessage.textContent = message;
    }

    function showSetupError(message) {
        setupError.textContent = message;
        setupError.style.display = 'block';
        setupButton.disabled = false;
        setupButton.textContent = 'Load Library';
    }
    </script>
</body>
</html>
