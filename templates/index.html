<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibre Library</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- sql.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.min.js"></script>
    <style>
        /* Additional styles for WASM browser */
        .status-bar {
            background: #34495e;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-bar .status-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .status-bar .badge {
            background: #27ae60;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.75rem;
        }
        .status-bar .badge.loading {
            background: #f39c12;
        }
        .status-bar .badge.error {
            background: #e74c3c;
        }
        .status-bar .badge.offline {
            background: #9b59b6;
        }
        .status-bar .badge.cached {
            background: #3498db;
        }
        .status-bar .actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .status-bar .refresh-btn {
            background: none;
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .status-bar .refresh-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .status-bar .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #ecf0f1;
            border-top-color: #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-text {
            margin-top: 1rem;
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        .progress-bar {
            width: 300px;
            height: 6px;
            background: #ecf0f1;
            border-radius: 3px;
            margin-top: 1rem;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background: #3498db;
            transition: width 0.3s;
        }
        .setup-inline {
            max-width: 500px;
            margin: 2rem auto;
            padding: 2rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .setup-inline h2 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }
        .setup-inline p {
            color: #7f8c8d;
            margin-bottom: 1.5rem;
        }
        .setup-form-inline .form-group {
            margin-bottom: 1.5rem;
        }
        .setup-form-inline label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }
        .setup-form-inline input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ecf0f1;
            border-radius: 4px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        .setup-form-inline input:focus {
            outline: none;
            border-color: #3498db;
        }
        .setup-form-inline small {
            display: block;
            margin-top: 0.5rem;
            color: #7f8c8d;
            font-size: 0.85rem;
        }
        .setup-button {
            width: 100%;
            padding: 1rem;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
        }
        .setup-button:hover {
            background-color: #2980b9;
        }
        .setup-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .error-message {
            background-color: #fee;
            color: #c00;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }
        .book-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .book-modal-content {
            background: white;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 8px;
            padding: 2rem;
            margin: 1rem;
            position: relative;
        }
        .book-modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #7f8c8d;
        }
        .book-modal-close:hover {
            color: #2c3e50;
        }
        .perf-stats {
            font-size: 0.75rem;
            color: #95a5a6;
        }
        /* Download Button */
        .download-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 0.75rem;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .download-btn:hover {
            background: #219a52;
        }
        .download-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        .download-btn .download-icon {
            font-size: 1rem;
            font-weight: bold;
        }
        .download-btn .download-size {
            font-size: 0.75rem;
            opacity: 0.85;
        }
        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 0.25rem;
            background: #ecf0f1;
            padding: 0.25rem;
            border-radius: 6px;
        }
        .view-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            color: #7f8c8d;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .view-btn:hover {
            color: #2c3e50;
            background: rgba(255,255,255,0.5);
        }
        .view-btn.active {
            background: white;
            color: #3498db;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        /* Table View */
        .books-table-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden;
            margin-bottom: 2rem;
        }
        .books-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        .books-table thead {
            background: #f8f9fa;
            border-bottom: 2px solid #ecf0f1;
        }
        .books-table th {
            text-align: left;
            padding: 1rem;
            font-weight: 600;
            color: #2c3e50;
            white-space: nowrap;
        }
        .books-table tbody tr {
            border-bottom: 1px solid #ecf0f1;
            cursor: pointer;
            transition: background-color 0.15s;
        }
        .books-table tbody tr:hover {
            background-color: #f8f9fa;
        }
        .books-table tbody tr:last-child {
            border-bottom: none;
        }
        .books-table td {
            padding: 0.875rem 1rem;
            color: #333;
        }
        .books-table .table-title {
            font-weight: 500;
            color: #2c3e50;
            max-width: 300px;
        }
        .books-table .table-author {
            color: #7f8c8d;
            max-width: 200px;
        }
        .books-table .table-series {
            color: #3498db;
            white-space: nowrap;
        }
        .books-table .table-rating {
            color: #f39c12;
            white-space: nowrap;
        }
        @media (max-width: 768px) {
            .books-table-container {
                overflow-x: auto;
            }
            .books-table {
                min-width: 600px;
            }
            .books-table th,
            .books-table td {
                padding: 0.75rem 0.5rem;
            }
            .books-table .table-title {
                max-width: 150px;
            }
            .view-toggle {
                margin-top: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h1 style="margin: 0;">
                    <a href="/" style="color: white; text-decoration: none;">Calibre Library</a>
                </h1>
                <button id="changeLibraryBtn" onclick="resetLibrary()" style="background: none; border: none; color: white; cursor: pointer; font-size: 0.9rem;">Change Library</button>
            </div>
            <form id="searchForm" class="search-form" style="display: none;">
                <input type="text" id="searchInput" placeholder="Search books or authors... (instant!)">
                <button type="submit">Search</button>
            </form>
        </div>
    </header>

    <div id="statusBar" class="status-bar" style="display: none;">
        <div class="status-text">
            <span id="statusBadge" class="badge">Ready</span>
            <span id="sourceBadge" class="badge cached" style="display: none;">Cached</span>
            <span id="statusMessage">Database loaded</span>
        </div>
        <div class="actions">
            <span id="perfStats" class="perf-stats"></span>
            <button id="refreshBtn" class="refresh-btn" onclick="refreshDatabase()">Refresh</button>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <div id="loadingText" class="loading-text">Initializing...</div>
        <div class="progress-bar">
            <div id="progressBarFill" class="progress-bar-fill" style="width: 0%"></div>
        </div>
    </div>

    <main class="container">
        <!-- Setup Section -->
        <div id="setupSection">
            <div class="setup-inline">
                <h2>Configure Calibre Library</h2>
                <p>Your database is downloaded once and cached locally. All queries run in your browser using WebAssembly - instant search, works offline!</p>

                <div id="setupError" class="error-message" style="display: none;"></div>

                <form id="setupForm" class="setup-form-inline">
                    <div class="form-group">
                        <label for="libraryPath">Calibre Library Path</label>
                        <input
                            type="text"
                            id="libraryPath"
                            name="libraryPath"
                            placeholder="/Calibre Library"
                            required
                        >
                        <small>The folder path in Dropbox containing your Calibre library</small>
                    </div>
                    <button type="submit" class="setup-button" id="setupButton">
                        Load Library
                    </button>
                </form>
            </div>
        </div>

        <!-- Library Section -->
        <div id="librarySection" style="display: none;">
            <div class="library-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 1rem;">
                    <div>
                        <h2 id="libraryTitle">All Books</h2>
                        <p class="book-count"><span id="bookCount">0</span> books found <span id="queryTime" class="perf-stats"></span></p>
                    </div>
                    <div class="view-toggle">
                        <button id="gridViewBtn" class="view-btn active" onclick="setView('grid')" title="Grid view">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <rect x="3" y="3" width="7" height="7" rx="1"/>
                                <rect x="14" y="3" width="7" height="7" rx="1"/>
                                <rect x="3" y="14" width="7" height="7" rx="1"/>
                                <rect x="14" y="14" width="7" height="7" rx="1"/>
                            </svg>
                        </button>
                        <button id="tableViewBtn" class="view-btn" onclick="setView('table')" title="Table view">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <rect x="3" y="4" width="18" height="2" rx="1"/>
                                <rect x="3" y="9" width="18" height="2" rx="1"/>
                                <rect x="3" y="14" width="18" height="2" rx="1"/>
                                <rect x="3" y="19" width="18" height="2" rx="1"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>

            <div id="booksGrid" class="books-grid"></div>
            <div id="booksTable" class="books-table-container" style="display: none;"></div>

            <div id="pagination" class="pagination" style="display: none;">
                <button id="prevBtn" class="pagination-link" onclick="prevPage()">Previous</button>
                <span id="pageInfo" class="pagination-info">Page 1 of 1</span>
                <button id="nextBtn" class="pagination-link" onclick="nextPage()">Next</button>
            </div>
        </div>
    </main>

    <!-- Book Detail Modal -->
    <div id="bookModal" class="book-modal" style="display: none;">
        <div class="book-modal-content">
            <button class="book-modal-close" onclick="closeModal()">&times;</button>
            <div id="bookDetail"></div>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>Powered by Calibre</p>
        </div>
    </footer>

    <script>
    // Global state
    let db = null;
    let SQL = null;
    let currentPage = 1;
    let perPage = 20;
    let currentSearch = '';
    let totalBooks = 0;
    let loadedFromCache = false;
    let isOffline = !navigator.onLine;

    const LIBRARY_PATH_KEY = 'calibreLibraryPath';
    const DB_CACHE_KEY = 'calibreMetadataDB';
    const VIEW_PREFERENCE_KEY = 'calibreViewPreference';
    let currentView = localStorage.getItem(VIEW_PREFERENCE_KEY) || 'grid';

    // Track online/offline status
    window.addEventListener('online', () => {
        isOffline = false;
        updateSourceBadge();
    });
    window.addEventListener('offline', () => {
        isOffline = true;
        updateSourceBadge();
    });

    // DOM elements
    const setupSection = document.getElementById('setupSection');
    const librarySection = document.getElementById('librarySection');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const progressBarFill = document.getElementById('progressBarFill');
    const searchForm = document.getElementById('searchForm');
    const searchInput = document.getElementById('searchInput');
    const statusBar = document.getElementById('statusBar');
    const statusBadge = document.getElementById('statusBadge');
    const sourceBadge = document.getElementById('sourceBadge');
    const statusMessage = document.getElementById('statusMessage');
    const refreshBtn = document.getElementById('refreshBtn');
    const setupError = document.getElementById('setupError');
    const setupButton = document.getElementById('setupButton');
    const libraryPathInput = document.getElementById('libraryPath');

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', init);

    async function init() {
        const storedPath = localStorage.getItem(LIBRARY_PATH_KEY);

        if (storedPath) {
            libraryPathInput.value = storedPath;
            await loadDatabase(storedPath);
        } else {
            setupSection.style.display = 'block';
        }
    }

    // Setup form handler
    document.getElementById('setupForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const libraryPath = libraryPathInput.value.trim();

        if (!libraryPath) {
            showSetupError('Library path is required');
            return;
        }

        localStorage.setItem(LIBRARY_PATH_KEY, libraryPath);
        await loadDatabase(libraryPath);
    });

    // Search handler with debounce
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            currentSearch = e.target.value.trim();
            currentPage = 1;
            renderBooks();
        }, 150); // Fast debounce for instant feel
    });

    searchForm.addEventListener('submit', (e) => {
        e.preventDefault();
        currentSearch = searchInput.value.trim();
        currentPage = 1;
        renderBooks();
    });

    async function loadDatabase(libraryPath, forceRefresh = false) {
        showLoading('Initializing sql.js...');
        setProgress(10);
        loadedFromCache = false;

        try {
            // Initialize sql.js
            if (!SQL) {
                try {
                    SQL = await initSqlJs({
                        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                    });
                } catch (sqlError) {
                    throw new Error('Failed to load SQLite engine. Please check your internet connection and try again.');
                }
            }
            setProgress(30);

            let dbData = null;

            // Try to load from IndexedDB cache first (unless forcing refresh)
            if (!forceRefresh) {
                showLoading('Checking cache...');
                try {
                    dbData = await loadFromCache();
                    if (dbData) {
                        loadedFromCache = true;
                        showLoading('Loading from cache...');
                        setProgress(70);
                    }
                } catch (cacheError) {
                    console.warn('Cache read failed, will download fresh:', cacheError);
                    // Cache might be corrupted, clear it
                    await clearCache();
                    dbData = null;
                }
            }

            if (!dbData) {
                // Download from server
                if (isOffline) {
                    throw new Error('You are offline and no cached database is available. Please connect to the internet and try again.');
                }

                showLoading('Downloading database from Dropbox...');
                setProgress(40);

                const response = await fetch('/api/download-db', {
                    headers: {
                        'X-Library-Path': libraryPath
                    }
                });

                if (!response.ok) {
                    let errorMsg = 'Failed to download database';
                    try {
                        const error = await response.json();
                        errorMsg = error.error || errorMsg;
                    } catch (e) {
                        // Response wasn't JSON
                    }
                    throw new Error(errorMsg);
                }

                setProgress(60);
                showLoading('Processing database...');

                const arrayBuffer = await response.arrayBuffer();
                dbData = new Uint8Array(arrayBuffer);

                // Cache in IndexedDB
                setProgress(80);
                showLoading('Caching for offline use...');
                try {
                    await saveToCache(dbData);
                } catch (cacheError) {
                    console.warn('Failed to cache database:', cacheError);
                    // Continue anyway, just won't have offline support
                }
            }

            setProgress(90);
            showLoading('Opening database...');

            // Try to create database, with error recovery
            try {
                db = new SQL.Database(dbData);
                // Verify database is valid by running a simple query
                db.exec("SELECT COUNT(*) FROM books");
            } catch (dbError) {
                console.error('Database appears corrupted:', dbError);
                if (loadedFromCache) {
                    // Cache was corrupted, clear it and retry
                    await clearCache();
                    hideLoading();
                    showLoading('Cache was corrupted, downloading fresh copy...');
                    return loadDatabase(libraryPath, true);
                }
                throw new Error('Downloaded database appears to be corrupted. Please try again.');
            }

            setProgress(100);
            hideLoading();

            // Show library
            setupSection.style.display = 'none';
            librarySection.style.display = 'block';
            searchForm.style.display = 'flex';
            statusBar.style.display = 'flex';

            updateStatus('Ready', `Database loaded (${formatBytes(dbData.length)})`, 'ready');
            updateSourceBadge();

            // Initialize view toggle buttons
            document.getElementById('gridViewBtn').classList.toggle('active', currentView === 'grid');
            document.getElementById('tableViewBtn').classList.toggle('active', currentView === 'table');

            // Render books
            renderBooks();

        } catch (error) {
            console.error('Failed to load database:', error);
            hideLoading();
            showSetupError(error.message);
            setupSection.style.display = 'block';
            librarySection.style.display = 'none';
            searchForm.style.display = 'none';
            statusBar.style.display = 'none';
        }
    }

    async function refreshDatabase() {
        const libraryPath = localStorage.getItem(LIBRARY_PATH_KEY);
        if (!libraryPath) return;

        if (isOffline) {
            alert('Cannot refresh while offline. Please connect to the internet and try again.');
            return;
        }

        refreshBtn.disabled = true;
        refreshBtn.textContent = 'Refreshing...';

        try {
            await clearCache();
            await loadDatabase(libraryPath, true);
        } finally {
            refreshBtn.disabled = false;
            refreshBtn.textContent = 'Refresh';
        }
    }

    function updateSourceBadge() {
        if (isOffline) {
            sourceBadge.textContent = 'Offline';
            sourceBadge.className = 'badge offline';
            sourceBadge.style.display = 'inline';
            refreshBtn.disabled = true;
        } else if (loadedFromCache) {
            sourceBadge.textContent = 'Cached';
            sourceBadge.className = 'badge cached';
            sourceBadge.style.display = 'inline';
            refreshBtn.disabled = false;
        } else {
            sourceBadge.textContent = 'Fresh';
            sourceBadge.className = 'badge';
            sourceBadge.style.display = 'inline';
            refreshBtn.disabled = false;
        }
    }

    function renderBooks() {
        if (!db) return;

        const startTime = performance.now();

        let books, total;

        if (currentSearch) {
            const result = searchBooks(currentSearch, currentPage, perPage);
            books = result.books;
            total = result.total;
            document.getElementById('libraryTitle').textContent = `Search: "${currentSearch}"`;
        } else {
            const result = getBooks(currentPage, perPage);
            books = result.books;
            total = result.total;
            document.getElementById('libraryTitle').textContent = 'All Books';
        }

        const queryTime = performance.now() - startTime;
        totalBooks = total;

        document.getElementById('bookCount').textContent = total;
        document.getElementById('queryTime').textContent = `(${queryTime.toFixed(1)}ms)`;
        document.getElementById('perfStats').textContent = `Query: ${queryTime.toFixed(1)}ms`;

        const grid = document.getElementById('booksGrid');
        const tableContainer = document.getElementById('booksTable');

        if (currentView === 'table') {
            // Render table view
            grid.style.display = 'none';
            tableContainer.style.display = 'block';
            tableContainer.innerHTML = `
                <table class="books-table">
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>Author</th>
                            <th>Series</th>
                            <th>Rating</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${books.map(book => `
                            <tr onclick="showBookDetail(${book.id})">
                                <td class="table-title">${escapeHtml(book.title)}</td>
                                <td class="table-author">${book.authors ? escapeHtml(book.authors) : '-'}</td>
                                <td class="table-series">${book.series ? escapeHtml(book.series) + (book.series_index ? ` #${book.series_index}` : '') : '-'}</td>
                                <td class="table-rating">${book.rating ? renderStars(book.rating) : '-'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        } else {
            // Render grid view
            grid.style.display = 'grid';
            tableContainer.style.display = 'none';
            grid.innerHTML = books.map(book => `
                <div class="book-card" onclick="showBookDetail(${book.id})">
                    <div class="book-link">
                        <div class="book-cover placeholder-cover">
                            <span>&#128218;</span>
                        </div>
                        <div class="book-info">
                            <h3 class="book-title">${escapeHtml(book.title)}</h3>
                            ${book.authors ? `<p class="book-author">${escapeHtml(book.authors)}</p>` : ''}
                            ${book.series ? `<p class="book-series">${escapeHtml(book.series)}${book.series_index ? ` #${book.series_index}` : ''}</p>` : ''}
                            ${book.rating ? `<div class="book-rating">${renderStars(book.rating)}</div>` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Update pagination
        const totalPages = Math.ceil(total / perPage);
        const pagination = document.getElementById('pagination');

        if (totalPages > 1) {
            pagination.style.display = 'flex';
            document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages}`;
            document.getElementById('prevBtn').disabled = currentPage <= 1;
            document.getElementById('nextBtn').disabled = currentPage >= totalPages;
        } else {
            pagination.style.display = 'none';
        }
    }

    function setView(view) {
        currentView = view;
        localStorage.setItem(VIEW_PREFERENCE_KEY, view);

        // Update toggle buttons
        document.getElementById('gridViewBtn').classList.toggle('active', view === 'grid');
        document.getElementById('tableViewBtn').classList.toggle('active', view === 'table');

        // Re-render books with new view
        renderBooks();
    }

    function getBooks(page, limit) {
        const offset = (page - 1) * limit;

        // Get total count
        const countResult = db.exec("SELECT COUNT(*) as count FROM books");
        const total = countResult[0].values[0][0];

        // Get books with authors, series, ratings
        const query = `
            SELECT
                b.id,
                b.title,
                b.path,
                b.has_cover,
                b.series_index,
                GROUP_CONCAT(a.name, ' & ') as authors,
                s.name as series,
                r.rating
            FROM books b
            LEFT JOIN books_authors_link bal ON b.id = bal.book
            LEFT JOIN authors a ON bal.author = a.id
            LEFT JOIN books_series_link bsl ON b.id = bsl.book
            LEFT JOIN series s ON bsl.series = s.id
            LEFT JOIN books_ratings_link brl ON b.id = brl.book
            LEFT JOIN ratings r ON brl.rating = r.id
            GROUP BY b.id
            ORDER BY b.sort
            LIMIT ${limit} OFFSET ${offset}
        `;

        const result = db.exec(query);
        const books = resultToObjects(result);

        return { books, total };
    }

    function searchBooks(term, page, limit) {
        const offset = (page - 1) * limit;
        const searchPattern = `%${term}%`;

        // Get total count
        const countQuery = `
            SELECT COUNT(DISTINCT b.id) as count
            FROM books b
            LEFT JOIN books_authors_link bal ON b.id = bal.book
            LEFT JOIN authors a ON bal.author = a.id
            WHERE b.title LIKE ? OR a.name LIKE ?
        `;

        const countStmt = db.prepare(countQuery);
        countStmt.bind([searchPattern, searchPattern]);
        countStmt.step();
        const total = countStmt.get()[0];
        countStmt.free();

        // Get books
        const query = `
            SELECT DISTINCT
                b.id,
                b.title,
                b.path,
                b.has_cover,
                b.series_index,
                GROUP_CONCAT(a.name, ' & ') as authors,
                s.name as series,
                r.rating
            FROM books b
            LEFT JOIN books_authors_link bal ON b.id = bal.book
            LEFT JOIN authors a ON bal.author = a.id
            LEFT JOIN books_series_link bsl ON b.id = bsl.book
            LEFT JOIN series s ON bsl.series = s.id
            LEFT JOIN books_ratings_link brl ON b.id = brl.book
            LEFT JOIN ratings r ON brl.rating = r.id
            WHERE b.title LIKE ? OR a.name LIKE ?
            GROUP BY b.id
            ORDER BY b.sort
            LIMIT ? OFFSET ?
        `;

        const stmt = db.prepare(query);
        stmt.bind([searchPattern, searchPattern, limit, offset]);

        const books = [];
        while (stmt.step()) {
            const row = stmt.getAsObject();
            books.push(row);
        }
        stmt.free();

        return { books, total };
    }

    function showBookDetail(bookId) {
        if (!db) return;

        const startTime = performance.now();

        // Get basic book info
        const query = `
            SELECT
                b.id,
                b.title,
                b.path,
                b.has_cover,
                b.pubdate,
                b.series_index,
                b.uuid,
                s.name as series,
                r.rating,
                p.name as publisher,
                c.text as comments
            FROM books b
            LEFT JOIN books_series_link bsl ON b.id = bsl.book
            LEFT JOIN series s ON bsl.series = s.id
            LEFT JOIN books_ratings_link brl ON b.id = brl.book
            LEFT JOIN ratings r ON brl.rating = r.id
            LEFT JOIN books_publishers_link bpl ON b.id = bpl.book
            LEFT JOIN publishers p ON bpl.publisher = p.id
            LEFT JOIN comments c ON b.id = c.book
            WHERE b.id = ?
        `;

        const stmt = db.prepare(query);
        stmt.bind([bookId]);
        stmt.step();
        const book = stmt.getAsObject();
        stmt.free();

        if (!book.id) {
            alert('Book not found');
            return;
        }

        // Get authors
        const authorsResult = db.exec(`
            SELECT a.name FROM authors a
            JOIN books_authors_link bal ON a.id = bal.author
            WHERE bal.book = ${bookId}
        `);
        book.authors = authorsResult.length ? authorsResult[0].values.map(r => r[0]) : [];

        // Get tags
        const tagsResult = db.exec(`
            SELECT t.name FROM tags t
            JOIN books_tags_link btl ON t.id = btl.tag
            WHERE btl.book = ${bookId}
        `);
        book.tags = tagsResult.length ? tagsResult[0].values.map(r => r[0]) : [];

        // Get formats (including filename for download)
        const formatsResult = db.exec(`
            SELECT format, uncompressed_size, name FROM data
            WHERE book = ${bookId}
        `);
        book.formats = formatsResult.length ? formatsResult[0].values.map(r => ({ format: r[0], size: r[1], name: r[2] })) : [];

        // Get identifiers
        const identifiersResult = db.exec(`
            SELECT type, val FROM identifiers
            WHERE book = ${bookId}
        `);
        book.identifiers = {};
        if (identifiersResult.length) {
            identifiersResult[0].values.forEach(r => {
                book.identifiers[r[0]] = r[1];
            });
        }

        const queryTime = performance.now() - startTime;

        // Render modal
        document.getElementById('bookDetail').innerHTML = `
            <div class="book-detail-container" style="display: block; box-shadow: none; padding: 0;">
                <h1 style="margin-bottom: 1rem;">${escapeHtml(book.title)}</h1>

                ${book.authors.length ? `<p class="detail-authors"><strong>Authors:</strong> ${book.authors.map(a => escapeHtml(a)).join(', ')}</p>` : ''}

                ${book.series ? `<p class="detail-series"><strong>Series:</strong> ${escapeHtml(book.series)}${book.series_index ? ` #${book.series_index}` : ''}</p>` : ''}

                ${book.rating ? `<p class="detail-rating">${renderStars(book.rating)}</p>` : ''}

                ${book.publisher ? `<p><strong>Publisher:</strong> ${escapeHtml(book.publisher)}</p>` : ''}

                ${book.pubdate ? `<p><strong>Published:</strong> ${new Date(book.pubdate).toLocaleDateString()}</p>` : ''}

                ${book.tags.length ? `
                    <div class="detail-tags" style="margin: 1rem 0;">
                        ${book.tags.map(t => `<span class="tag">${escapeHtml(t)}</span>`).join('')}
                    </div>
                ` : ''}

                ${book.formats.length ? `
                    <div class="detail-formats" style="margin: 1rem 0;">
                        <strong>Formats:</strong>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
                            ${book.formats.map(f => `
                                <button class="download-btn" data-path="${escapeAttr(book.path)}" data-name="${escapeAttr(f.name)}" data-format="${f.format}" onclick="downloadBook(this.dataset.path, this.dataset.name, this.dataset.format)" title="Download ${f.format} (${formatBytes(f.size)})">
                                    <span class="download-icon">&#8595;</span>
                                    ${f.format}
                                    <span class="download-size">${formatBytes(f.size)}</span>
                                </button>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}

                ${book.comments ? `
                    <div class="detail-description">
                        <strong>Description:</strong>
                        <div class="description-text">${book.comments}</div>
                    </div>
                ` : ''}

                ${Object.keys(book.identifiers).length ? `
                    <div class="detail-identifiers" style="margin-top: 1rem;">
                        <strong>Identifiers:</strong>
                        ${Object.entries(book.identifiers).map(([k, v]) => `${k.toUpperCase()}: ${escapeHtml(v)}`).join(' | ')}
                    </div>
                ` : ''}

                <p class="perf-stats" style="margin-top: 1rem;">Query time: ${queryTime.toFixed(1)}ms</p>
            </div>
        `;

        document.getElementById('bookModal').style.display = 'flex';
    }

    function closeModal() {
        document.getElementById('bookModal').style.display = 'none';
    }

    // Close modal on escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeModal();
    });

    // Close modal on background click
    document.getElementById('bookModal').addEventListener('click', (e) => {
        if (e.target.id === 'bookModal') closeModal();
    });

    function prevPage() {
        if (currentPage > 1) {
            currentPage--;
            renderBooks();
            window.scrollTo(0, 0);
        }
    }

    function nextPage() {
        const totalPages = Math.ceil(totalBooks / perPage);
        if (currentPage < totalPages) {
            currentPage++;
            renderBooks();
            window.scrollTo(0, 0);
        }
    }

    function resetLibrary() {
        localStorage.removeItem(LIBRARY_PATH_KEY);
        clearCache();
        db = null;
        setupSection.style.display = 'block';
        librarySection.style.display = 'none';
        searchForm.style.display = 'none';
        statusBar.style.display = 'none';
    }

    // IndexedDB cache functions
    function openCacheDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('CalibreWASM', 1);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('cache')) {
                    db.createObjectStore('cache');
                }
            };
        });
    }

    async function saveToCache(data) {
        try {
            const cacheDB = await openCacheDB();
            const tx = cacheDB.transaction('cache', 'readwrite');
            const store = tx.objectStore('cache');
            store.put(data, DB_CACHE_KEY);
            store.put(Date.now(), DB_CACHE_KEY + '_timestamp');
            store.put(localStorage.getItem(LIBRARY_PATH_KEY), DB_CACHE_KEY + '_path');
            await new Promise((resolve, reject) => {
                tx.oncomplete = resolve;
                tx.onerror = () => reject(tx.error);
            });
        } catch (e) {
            console.warn('Failed to cache database:', e);
        }
    }

    async function loadFromCache() {
        try {
            const cacheDB = await openCacheDB();
            const tx = cacheDB.transaction('cache', 'readonly');
            const store = tx.objectStore('cache');

            const currentPath = localStorage.getItem(LIBRARY_PATH_KEY);
            const cachedPath = await new Promise((resolve, reject) => {
                const req = store.get(DB_CACHE_KEY + '_path');
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });

            // If path changed, don't use cache
            if (cachedPath !== currentPath) {
                return null;
            }

            const data = await new Promise((resolve, reject) => {
                const req = store.get(DB_CACHE_KEY);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });

            return data || null;
        } catch (e) {
            console.warn('Failed to load from cache:', e);
            return null;
        }
    }

    async function clearCache() {
        try {
            const cacheDB = await openCacheDB();
            const tx = cacheDB.transaction('cache', 'readwrite');
            const store = tx.objectStore('cache');
            store.delete(DB_CACHE_KEY);
            store.delete(DB_CACHE_KEY + '_timestamp');
            store.delete(DB_CACHE_KEY + '_path');
        } catch (e) {
            console.warn('Failed to clear cache:', e);
        }
    }

    // Utility functions
    function resultToObjects(result) {
        if (!result.length) return [];
        const columns = result[0].columns;
        return result[0].values.map(row => {
            const obj = {};
            columns.forEach((col, i) => {
                obj[col] = row[i];
            });
            return obj;
        });
    }

    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function escapeAttr(text) {
        if (!text) return '';
        return text.replace(/&/g, '&amp;')
                   .replace(/"/g, '&quot;')
                   .replace(/'/g, '&#39;')
                   .replace(/</g, '&lt;')
                   .replace(/>/g, '&gt;');
    }

    function renderStars(rating) {
        const stars = Math.floor((rating || 0) / 2);
        return '&#9733;'.repeat(stars) + '&#9734;'.repeat(5 - stars);
    }

    function formatBytes(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function showLoading(text) {
        loadingOverlay.style.display = 'flex';
        loadingText.textContent = text;
    }

    function hideLoading() {
        loadingOverlay.style.display = 'none';
    }

    function setProgress(percent) {
        progressBarFill.style.width = percent + '%';
    }

    function updateStatus(badge, message, type = 'ready') {
        statusBadge.textContent = badge;
        statusBadge.className = 'badge' + (type !== 'ready' ? ' ' + type : '');
        statusMessage.textContent = message;
    }

    function showSetupError(message) {
        setupError.textContent = message;
        setupError.style.display = 'block';
        setupButton.disabled = false;
        setupButton.textContent = 'Load Library';
    }

    async function downloadBook(bookPath, fileName, format) {
        const libraryPath = localStorage.getItem(LIBRARY_PATH_KEY);
        if (!libraryPath) {
            alert('Library path not configured');
            return;
        }

        // Build the file path: bookPath/fileName.format
        const filePath = `${bookPath}/${fileName}.${format.toLowerCase()}`;

        // Find the button that was clicked and show loading state
        const buttons = document.querySelectorAll('.download-btn');
        let clickedButton = null;
        buttons.forEach(btn => {
            if (btn.textContent.includes(format)) {
                clickedButton = btn;
                btn.disabled = true;
                btn.querySelector('.download-icon').textContent = '...';
            }
        });

        try {
            const response = await fetch(`/api/download-link?path=${encodeURIComponent(filePath)}`, {
                headers: {
                    'X-Library-Path': libraryPath
                }
            });

            const data = await response.json();

            if (!data.success) {
                throw new Error(data.error || 'Failed to get download link');
            }

            // Open the download link in a new tab/window
            window.open(data.link, '_blank');

        } catch (error) {
            console.error('Download failed:', error);
            alert('Download failed: ' + error.message);
        } finally {
            // Restore button state
            if (clickedButton) {
                clickedButton.disabled = false;
                clickedButton.querySelector('.download-icon').textContent = 'â†“';
            }
        }
    }
    </script>
</body>
</html>
